//
// Travel Mapping (TM) Data Viewer-related Javascript functions
// formerly for Clinched Highway Mapping (CHM) data
//
// Load and view data files related to TM-related academic data sets.
//
// Renamed as tmjsfuncs.js as part of the Travel Mapping project
//
// Primary author: Jim Teresco, Siena College, The College of Saint Rose
// Additional authors: Razie Fathi, Arjol Pengu, Maria Bamundo, Clarice Tarbay
//
// Portions of this code developed based on examples from 
// http://cmap.m-plex.com/tools/wptedit/wptedit.html
// http://www.alecjacobson.com/weblog/?p=1645
//
// Modification History (pre-GitHub):
//
// 2011-06-20 JDT  Initial implementation
// 2011-06-21 JDT  Added .gra support and checkbox for hidden marker display
// 2011-06-23 JDT  Added .nmp file support (near-miss points)
// 2011-08-23 JDT  Added .pth file support (path)
// 2011-08-31 JDT  Added tabular graph data display
// 2013-08-14 JDT  Completed conversion to Google Maps API V3
// 2013-08-15 JDT  Added custom icon for intersections
// 2013-12-08 JDT  Fixed to handle DOS-style CRLF in uploaded files
// 2013-12-25 JDT  Click on GRA, PTH point label in table recenters map
// 2014-11-17 JDT  Added .wpl file support (waypoint list)
// 2015-06-10 JDT  Adapted for reading from database entries using PHP
// 2015-06-14 JDT  Clinched segment support
// 2015-06-17 JDT  All highways in region support
// 2015-08-19 JDT  Fixed a few bugs with infowindows
// 2016-05-25 JDT  Consolidated some changes from copies of chmviewerfunc3.js
// 2016-06-27 JDT  Removed code not needed by TM
//

// IMPORTANT: when making any modifications to code here, especially
// the loadmap function, note that it is used by various TM pages,
// where variables are mostly set in code generated by waypoints.js.php,
// but also by HDX, where variables are set in various places in
// hdxjsfuncs.js

// get path to lib directory where some images are found,
// which *might* have been set from an hdx.conf file.
var tmlibdir = "/lib/";
try {
    tmlibdir = tmliburl;
}
catch(e) {}

// global variable to hold the map, which will be assigned a
// Leaflet L.Map reference
var map;

// map status possibilities
var mapStates = {
    NO_MAP: 1,
    HB_ROUTE: 2,
    MAPVIEW: 3,
    HDX: 4
};

var mapStatus = mapStates.NO_MAP;

// many of the following are given values in code generated by
// waypoints.js.php for TM functionality, or by functions in
// hdx*.js (in EduTools/HighwayDataExaminer) for HDX functionality.

// array of waypoints displayed
var waypoints = new Array();
// array of waypoint custom marker colors (used for NMPs)
var waypointColors = new Array();
// info about each route included (each entry is a structure)
var routeInfo = new Array();
// the markers at those waypoints
var markers = new Array();
// array of connections on map as Polyline overlays
var connections = new Array();

// highlight connection when a popup on it is displayed
var highlightConnection = null;

// array of graph edges (for graph data, used by HDX, which imports this code) -
// this would be a single list of all graph edges.  When using an adjacency
// list representation, edges would also be in vertex-based adjacency lists
var graphEdges = new Array();
// boolean to determine if graph edges should be generated automatically
var genEdges = false;
// boolean to determine if graph edges are in vertex adjacency lists
var usingAdjacencyLists = false;
// boolean to determine if graph edges include traveler info
var haveTravelers = false;
// array of traveler names corresponding to traveler numbers for edges
var travelerNames = new Array();
// largest number of travelers on any edge
var maxEdgeTravelers = 0;

// array of segments and clinched for "clinched by traveler" mapping
var segments = new Array();
var clinched = new Array();
// boolean to say if we're doing this
var mapClinched = false;
// traveler name for clinched
var traveler;

// are we in mapview, and loading data dynamically?
var showAllInView = false;

// preferred units
var distanceUnits = "miles";

// array of objects that define color codes from names in the DB
var colorCodes = new Array();
colorCodes[0] = { name: "TMblue", unclinched: "rgb(100,100,255)", clinched: "rgb(0,0,220)" };
colorCodes[1] = { name: "TMbrown", unclinched: "rgb(153,152,102)", clinched: "rgb(153,102,0)" };
colorCodes[2] = { name: "TMred", unclinched: "rgb(255,100,100)", clinched: "rgb(224,0,0)" };
colorCodes[3] = { name: "TMyellow", unclinched: "rgb(255,216,100)", clinched: "rgb(232,176,0)" };
colorCodes[4] = { name: "TMteal", unclinched: "rgb(100,200,200)", clinched: "rgb(0,140,160)" };
colorCodes[5] = { name: "TMgreen", unclinched: "rgb(100,200,100)", clinched: "rgb(0,224,0)" };
colorCodes[6] = { name: "TMmagenta", unclinched: "rgb(255,100,255)", clinched: "rgb(208,0,208)" };
colorCodes[7] = { name: "TMlightsalmon", unclinched: "rgb(224,162,162)", clinched: "rgb(240,150,115)" };
colorCodes[8] = { name: "TMgray", unclinched: "rgb(100,100,100)", clinched: "rgb(100,100,100)" };
colorCodes[9] = { name: "TMdarkgreen", unclinched: "rgb(61,94,77)", clinched: "rgb(24,132,70)" };
colorCodes[10] = { name: "TMpurple", unclinched: "rgb(128,0,128)", clinched: "rgb(150,28,220)" };
colorCodes[11] = { name: "TMorange", unclinched: "rgb(255,180,50)", clinched: "rgb(255,165,0)" };

// array of custom color codes to be pulled from query string parameter
// "colors="
var customColorCodes = new Array();

// colors to use when plotting based on concurrency counts of segments
var concurrencyColors = [ "", "#0000FF", "#00FF00", "#FF00FF", "#FFFF00",
			  "#FF0000", "#00FFFF", "#700080", "#B0B000",
			  "#FF8000", "#808080" ];

// current Polyline weight, updated by zoomChange
var polylineWeight = 10;

var intersectionimage = L.icon({
    iconUrl: tmlibdir + 'Intersection.png',
    // This marker is 16x16
    iconSize: [16, 16]});

var oldintersectionimage = L.icon({
    iconUrl: tmlibdir + 'smallintersection.png',
    // This marker is 16x16
    iconSize: [16, 16]});

// map tiles associative array will be filled in by loadmap
var baseLayers;

// initial default coordinates at Roger Bacon 321 at Siena College
let setlat = 42.719450;
let setlon = -73.752063;
let setzoom =  14;

// current location, which will be updated by mapLocationFound
let currentLocation = null;

// marker at current location, to be repositioned to follow currentLocation
let currentLocationMarker = null;

// what should be done for map positioning by the next callback that
// parses JSON output to display info on the map
var mapPosUpdates = {
    NONE: 1,
    USE_LAT_LON_ZOOM: 2,
    FIT_TO_DATA: 3
};

var nextMapPosUpdate = mapPosUpdates.NONE;

// functions to manage browser cookies (based on examples at
// https://www.w3schools.com/js/js_cookies.asp)
function setTMCookie(name, value) {

    // we'll have the cookie remain for a year
    let d = new Date();
    d.setTime(d.getTime() + 365*24*60*60*1000);
    document.cookie = name + "=" + value + ";expires="
	+ d.toUTCString() + ";path=/;secure";
}

function getTMCookie(name) {

    let allcookies = decodeURIComponent(document.cookie).split(';');
    for (let i = 0; i < allcookies.length; i++) {
	let cookie = allcookies[i];
	// remove leading spaces
	while (cookie.charAt(0) == ' ') {
	    cookie = cookie.substring(1);
	}
	if (cookie.indexOf(name) == 0) {
	    return cookie.substring(name.length+1, cookie.length);
	}
    }
    return "";
}

// convert a distance in miles to the current units
// Note: floating point return type
function convertToCurrentUnits(miles) {

    if (distanceUnits == "miles") {
	return miles * 1.0;  // force numeric return
    }
    if (distanceUnits == "km") {
	return miles * 1.609344;
    }
    if (distanceUnits == "ft") {
	return miles * 5280;
    }
    if (distanceUnits == "meters") {
	return miles * 1609.344;
    }
}

// display a distance in miles in the current units, with units include
// Note: return type String
function length_in_current_units(miles) {

    if (distanceUnits == "miles") {
	return miles.toFixed(2) + " mi";
    }
    if (distanceUnits == "km") {
	return (miles * 1.609344).toFixed(2) + " km";
    }
    if (distanceUnits == "ft") {
	return (miles * 5280).toFixed(1) + " ft";
    }
    if (distanceUnits == "meters") {
	return (miles * 1609.344).toFixed(1) + " m";
    }
}

// where are we?
function mapLocationFound(e) {

    currentLocation = e.latlng;
    if (currentLocationMarker == null) {
	currentLocationMarker = L.marker(currentLocation);
	currentLocationMarker.addTo(map);
    }
    else {
	currentLocationMarker.setLatLng(currentLocation);
    }
}

// could not find map location
function mapLocationError(e) {

    document.getElementById("posCheckbox").checked = false;
    let label = document.getElementById("posCheckboxLabel");
    label.innerHTML = "Location Failed";
    posCheckboxChanged();
    
}

// Turn on/off detection and display of current position.
// This assumes it is the callback for a checkbox with id "posCheckbox"
// created as part of a page displaying the map.  If no such checkbox
// exists, this function should never be called and no location queries
// will be made and no position marker will be displayed.
function posCheckboxChanged() {

    let posCheckbox = document.getElementById("posCheckbox");
    if (posCheckbox.checked) {
	// show current location, if possible
	map.on('locationfound', mapLocationFound);
	map.on('locationerror', mapLocationError);
	map.locate({ watch: true });
	let label = document.getElementById("posCheckboxLabel");
	label.innerHTML = "Mark Current Location";
	setTMCookie("TMgetLocation", "checked");
    }
    else {
	map.off('locationfound', mapLocationFound);
	map.off('locationerror', mapLocationError);
	map.stopLocate();
	if (currentLocationMarker != null) {
	    currentLocationMarker.remove();
	    currentLocationMarker = null;
	}
	setTMCookie("TMgetLocation", "unchecked");
    }
}

// loadmap constructs and sets up the initial map
function loadmap() {

    // Leaflet map object
    map = L.map('map', {
	renderer: L.canvas()});

    // initial default
    map.setView([setlat, setlon], setzoom);

    // display default scale
    L.control.scale().addTo(map);

    // is there a toggle to try to show current location?
    let posCheckbox = document.getElementById("posCheckbox");
    if (posCheckbox != null) {
	// read the cookie to set the checkbox based on last use
	let checkPosCookie = getTMCookie("TMgetLocation");
	if (checkPosCookie == "unchecked") {
	    posCheckbox.checked = false;
	}
	// set up/disable location watch
	posCheckboxChanged();
    }
    
    // set up map tiles based on
    // https://github.com/leaflet-extras/leaflet-providers/blob/master/index.html
    baseLayers = {
	'OpenStreetMap Default': L.tileLayer.provider('OpenStreetMap.Mapnik'),
	'OpenStreetMap Germany': L.tileLayer.provider('OpenStreetMap.DE'),
	'OpenStreetMap France': L.tileLayer.provider('OpenStreetMap.France'),
	//'OpenStreetMap Black and White': L.tileLayer.provider('OpenStreetMap.BlackAndWhite'),
	'OpenStreetMap H.O.T.': L.tileLayer.provider('OpenStreetMap.HOT'),
	//'OpenRailwayMap': L.tileLayer.provider('OpenRailwayMap'),
	'HERE Normal Day': L.tileLayer.provider('HERE.terrainDay', {
	    app_id: here_map_id, 
	    app_code: here_map_code
	}),
	'HERE Hybrid Day': L.tileLayer.provider('HERE.hybridDay', {
	    app_id: here_map_id, 
	    app_code: here_map_code
	}),
	'Jawg Terrain': L.tileLayer.provider('Jawg', {
	    variant: 'jawg-terrain',
	    accessToken: jawg_map_token
	}),
	'Jawg Streets': L.tileLayer.provider('Jawg', {
	    variant: 'jawg-streets',
	    accessToken: jawg_map_token
	}),
	'Jawg Sunny': L.tileLayer.provider('Jawg', {
	    variant: 'jawg-sunny',
	    accessToken: jawg_map_token
	}),
	'Jawg Light': L.tileLayer.provider('Jawg', {
	    variant: 'jawg-light',
	    accessToken: jawg_map_token
	}),
	'Jawg Dark': L.tileLayer.provider('Jawg', {
	    variant: 'jawg-dark',
	    accessToken: jawg_map_token
	}),
	'Jawg Matrix': L.tileLayer.provider('Jawg', {
	    variant: 'jawg-matrix',
	    accessToken: jawg_map_token
	}),
	'Carto Light': L.tileLayer.provider('CartoDB'),
	'Carto Dark': L.tileLayer.provider('CartoDB', {
	    variant: 'dark_all'
	}),
	'Carto Voyager': L.tileLayer.provider('CartoDB', {
	    variant: 'rastertiles/voyager'
	}),
	'Carto Light No Labels': L.tileLayer.provider('CartoDB', {
	    variant: 'light_nolabels'
	}),
	'Carto Dark No Labels': L.tileLayer.provider('CartoDB', {
	    variant: 'dark_nolabels'
	}),
	'Carto Voyager No Labels': L.tileLayer.provider('CartoDB', {
	    variant: 'rastertiles/voyager_nolabels'
	}),
	'Stamen Toner': L.tileLayer.provider('Stamen.Toner'),
	'Stamen TonerLite': L.tileLayer.provider('Stamen.TonerLite'),
	'Stamen TonerBackground': L.tileLayer.provider('Stamen.TonerBackground'),
	'Stamen Terrain': L.tileLayer.provider('Stamen.Terrain'),
	//'Stadia': L.tileLayer.provider('Stadia.Outdoors'),
	'Esri WorldStreetMap': L.tileLayer.provider('Esri.WorldStreetMap'),
	//'Esri DeLorme': L.tileLayer.provider('Esri.DeLorme'),
	'Esri WorldTopoMap': L.tileLayer.provider('Esri.WorldTopoMap'),
	'Esri WorldImagery': L.tileLayer.provider('Esri.WorldImagery'),
	//'Esri WorldTerrain': L.tileLayer.provider('Esri.WorldTerrain'),
	'Esri NatGeoWorldMap': L.tileLayer.provider('Esri.NatGeoWorldMap'),
	'Esri WorldGrayCanvas': L.tileLayer.provider('Esri.WorldGrayCanvas'),
	'Thunderforest Landscape': L.tileLayer.provider('Thunderforest.Landscape', {
	    apikey: tf_map_key
	}),
	'Thunderforest Transport': L.tileLayer.provider('Thunderforest.Transport', {
	    apikey: tf_map_key
	}),
	'Thunderforest Transport Dark': L.tileLayer.provider('Thunderforest.TransportDark', {
	    apikey: tf_map_key
	}),
	'USGS Imagery/Topo': L.tileLayer.provider('USGS.USImageryTopo'),
	'OPNVKarte': L.tileLayer.provider('OPNVKarte'),
	'TM Blank White': L.tileLayer.provider('TMBlank.White'),
	'TM Blank Black': L.tileLayer.provider('TMBlank.Black'),
	'Thunderforest Spinal Map': L.tileLayer.provider('Thunderforest.SpinalMap', {
	    apikey: tf_map_key
	})
    };
    // previously included:
    /*
Mapbox is out: no way to ensure we don't exceed the limits of the free access.
	'Mapbox Streets': L.tileLayer.provider('MapBox', {
	    id: 'mapbox.streets',
	    accessToken: mapbox_token
	}),
	'Mapbox Satellite': L.tileLayer.provider('MapBox', {
	    id: 'mapbox.satellite',
	    accessToken: mapbox_token
	}),
	'Mapbox Streets+Satellite': L.tileLayer.provider('MapBox', {
	    id: 'mapbox.streets-satellite',
	    accessToken: mapbox_token
	}),
	'Mapbox Emerald': L.tileLayer.provider('MapBox', {
	    id: 'mapbox.emerald',
	    accessToken: mapbox_token
	}),
*/
	//'Hydda Full': L.tileLayer.provider('Hydda.Full'),
	//'Thunderforest OpenCycleMap': L.tileLayer.provider('Thunderforest.OpenCycleMap', {
	//    apikey: tf_map_key
	//}),
	//'Thunderforest Transport': L.tileLayer.provider('Thunderforest.Transport', {
	//    apikey: tf_map_key
	//}),
	//'Thunderforest TransportDark': L.tileLayer.provider('Thunderforest.TransportDark', {
	//    apikey: tf_map_key
	//}),
	//'Thunderforest Outdoors': L.tileLayer.provider('Thunderforest.Outdoors', {
	//    apikey: tf_map_key
	//}),
	//'Thunderforest Pioneer': L.tileLayer.provider('Thunderforest.Pioneer', {
	//    apikey: tf_map_key
	//}),
	//'Esri WorldShadedRelief': L.tileLayer.provider('Esri.WorldShadedRelief'),
	//'Esri WorldPhysical': L.tileLayer.provider('Esri.WorldPhysical'),
	//'Esri OceanBasemap': L.tileLayer.provider('Esri.OceanBasemap'),
	//'Stamen Watercolor': L.tileLayer.provider('Stamen.Watercolor'),

    var overlays = { };
    L.control.layers(baseLayers, overlays).addTo(map);

    // set layer to start with based on cookie if one exists
    let defaultLayerName = 'OpenStreetMap Default';
    let cookieLayerName = getTMCookie("maptile");
    if (cookieLayerName != "" && cookieLayerName in baseLayers) {
	defaultLayerName = cookieLayerName;
    }
    baseLayers[defaultLayerName].addTo(map);

    // if map tile layer is changed, remember it in a cookie
    map.on('baselayerchange', function(e) {
	let selectedMap = "NOT FOUND";
	for (var mapname in baseLayers) {
	    if (map.hasLayer(baseLayers[mapname])) {
		selectedMap = mapname;
		break;
	    }
	}
	setTMCookie("maptile", selectedMap);
    });
}

// construct a new Waypoint object (based on similar function by Tim Reichard)
// now supporting edge adjacency lists
// these sometimes have a field "intersecting" added to them which is
// an array of intersecting Routes (defined below)
function Waypoint(label, lat, lon, elabel, edgeList) {
    this.label = label;
    this.lat = Number(parseFloat(lat).toFixed(6));
    this.lon = Number(parseFloat(lon).toFixed(6));
    this.visible = true;
    if (label.indexOf("+") >= 0) {
	this.visible = false;
    }
    this.elabel = elabel;
    this.edgeList = edgeList;
    return this;
}

// construct a Route object to encapsulate information needed for intersecting
// routes
function Route(root, route, region, banner, abbrev, city) {

    this.root = root;
    this.route = route;
    this.region = region;
    this.banner = banner;
    this.abbrev = abbrev;
    this.city = city;
    return this;
}

// update the map to the current set of waypoints and connections
function updateMap(lat, lon, zoom)
{
    // remove any existing Polyline connections shown
    for (var i = 0; i < connections.length; i++) {
	connections[i].remove();
    }
    connections = new Array();

    // set up to find bounding box of points we plot
    var minlat = 999;
    var maxlat = -999;
    var minlon = 999;
    var maxlon = -999;

    // remove any markers previously on the map
    for (var i = 0; i < markers.length; i++) {
	markers[i].remove();
    }
    markers = new Array();

    // set variable that determine if markers should be drawn on the map
    var showMarkers = true;
    if (document.getElementById('showMarkers') != null) {
      showMarkers = document.getElementById('showMarkers').checked;
    }

    for (var i = 0; i < waypoints.length; i++) {
	minlat = Math.min(minlat, waypoints[i].lat);
	maxlat = Math.max(maxlat, waypoints[i].lat);
	minlon = Math.min(minlon, waypoints[i].lon);
	maxlon = Math.max(maxlon, waypoints[i].lon);
	
	let icon = intersectionimage;
	if (waypointColors.length > i) {
	    let options = {
		iconShape: 'circle-dot',
		iconSize: [4, 4],
		iconAnchor: [4, 4],
		borderWidth: 4,
		borderColor: waypointColors[i]
	    };
	    
	    icon = L.BeautifyIcon.icon(options);
	}
	markers[i] = L.marker([waypoints[i].lat, waypoints[i].lon], {
	    title: waypoints[i].label,
	    icon: icon
	});
	if (showMarkers && waypoints[i].visible) {
	    addMarker(markers[i], i);
	}
    }

    // set our map view based on
    // 1) QS parameters if they were passed
    // 2) bounds of points if we already have them from waypointsFromSQL
    // 3) find out with a popup
    if (lat != null && lon != null && zoom != null) {
        // according to lat,lon,zoom if provided in URL, or else...
        map.setView([lat, lon], zoom);
    }
    else if (minlat != 999) {
        // according to the bounds we found above
        map.fitBounds([[minlat, minlon],[maxlat, maxlon]]);
    }
    else {
	// need to query to find where to start the map
	console.log("updateMap at showScrollableMapviewPopup: Code should no longer happen!");
	showScrollableMapviewPopup();
	// cut this call short, will redo on the callback
	return;
    }

    // determine if the user has selected a custom unit of distance
    distanceUnits = getTMCookie("units");
    if (distanceUnits == "") distanceUnits = "miles";

    // if we are in a scrollable mapview, none of the cases below is
    // relevant, we just set our map zoom/pan callbacks which will
    // query the DB and update the map/table
    if (showAllInView) {
	console.log("updateMap at showAllInView: Code should no longer happen!");
        map.on('moveend', zoomChange);
        map.on('resize', zoomChange);
	// commented out as it appears that a moveend is also fired
	// for a zoomend, so we would get a double update
        //map.on('zoomend', zoomChange);
        zoomChange();
    }
    // if this is a graph in HDX, we draw edges as connections,
    // otherwise we may be connecting waypoints in order to plot a
    // path
    else if (graphEdges.length > 0) {
	for (var i = 0; i < graphEdges.length; i++) {
	    var numPoints;
	    if (graphEdges[i].via == null) {
		numPoints = 2;
	    }
	    else {
		numPoints = graphEdges[i].via.length/2 + 2;
	    }
	    var edgePoints = new Array(numPoints);
	    var v1 = graphEdges[i].v1;
	    var v2 = graphEdges[i].v2;
	    //	    DBG.write("Adding edge " + i + " from " + v1 + "(" + waypoints[v1].lat + "," + waypoints[v1].lon + ") to " + v2 + "(" + waypoints[v2].lat + "," + waypoints[v2].lon + ")");
	    edgePoints[0] = [waypoints[v1].lat, waypoints[v1].lon];
	    nextPoint = 1;
	    if (graphEdges[i].via != null) {
		for (var j = 0; j < graphEdges[i].via.length; j+=2) {
		    edgePoints[nextPoint] = [graphEdges[i].via[j], graphEdges[i].via[j+1]];
		    nextPoint++;
		}
	    }
	    edgePoints[nextPoint] = [waypoints[v2].lat, waypoints[v2].lon];
	    // check for custom colors for NMP "graphs"
	    if (waypointColors.length > v2) {
		color = waypointColors[v2];
	    }
	    else {
		color = getGraphEdgeColor(graphEdges[i]);
	    }
            connections[i] = L.polyline(edgePoints, {
                color: color,
                weight: polylineWeight,
                opacity: 0.4
            }).addTo(map);
	    connectionListener({connIndex: i});
	}
    }
    else if (usingAdjacencyLists) {
	// From HDX, TMG files and PTH files use adjacency lists, but
	// TMG files also have a graph edges array, so are handled above
	// meaning that much of this code is overkill, as PTH file "graphs"
	// are fairly trivial
	var edgeNum = 0;
	for (var i = 0; i < waypoints.length; i++) {
	    for (var j = 0; j < waypoints[i].edgeList.length; j++) {
		var thisEdge = waypoints[i].edgeList[j];
		// avoid double plot by only plotting those with v1 as i
		if (thisEdge.v1 == i) {
		    var numPoints;
		    if (thisEdge.via == null) {
			numPoints = 2;
		    }
		    else {
			numPoints = thisEdge.via.length/2 + 2;
		    }
		    var edgePoints = new Array(numPoints);
		    edgePoints[0] = [waypoints[thisEdge.v1].lat, waypoints[thisEdge.v1].lon];
		    nextPoint = 1;
		    if (thisEdge.via != null) {
			for (var p = 0; p < thisEdge.via.length; p+=2) {
			    edgePoints[nextPoint] = [thisEdge.via[p], thisEdge.via[p+1]];
			    nextPoint++;
			}
		    }
		    edgePoints[nextPoint] = [waypoints[thisEdge.v2].lat, waypoints[thisEdge.v2].lon];
		    
		    color = getGraphEdgeColor(thisEdge);
                    connections[edgeNum] = L.polyline(edgePoints, {
                        color: color,
                        weight: polylineWeight,
                        opacity: 0.4
                    }).addTo(map);
		    connectionListener({connIndex: edgeNum});
		    edgeNum++;
		}
	    }
	}
        map.on('zoomend', zoomChange);
        zoomChange();
    }
    // connecting waypoints in order to plot a path
    // this could be a single route in an HB context or a bunch of
    // routes in a mapview context (also, system/region)
    else if (mapClinched) {
	console.log("updateMap at mapClinched: Code should no longer happen!");
	// clinched vs unclinched segments mapped with different colors
	var nextClinchedCheck = 0;
	var totalMiles = 0.0;
	var clinchedMiles = 0.0;
	var level = map.getZoom();
	var weight = 2;
	if (routeInfo.length > 0) {
	    // if routeInfo is not empty, we're plotting multiple routes
	    // (maybe check mapStatus for MAPVIEW instead, needs testing)
	    var nextSegment = 0;
	    // segmentLengths will have properties added to it where
	    // keys are the lengths of segments and the value for each
	    // is a list of segment numbers which are of that length, used
	    // to make sure only one Polyline is plotted for any segment
	    // that contains concurrencies
	    let segmentLengths = new Object();
	    for (var route = 0; route < routeInfo.length; route++) {
		var start = routeInfo[route].firstWaypoint;
		var end;
		if (route == routeInfo.length-1) {
		    end = waypoints.length-1;
		}
		else {
		    end = routeInfo[route+1].firstWaypoint-1;
		}
		
		// use clinch colors from systems.csv
		let colors = lookupColors(routeInfo[route].color,
					 routeInfo[route].tier,
					 routeInfo[route].system);
		let unclinchedColor = colors[0];
		let clinchedColor = colors[1];

		// remember the index into the connections array where this
		// route's first connection is stored, as an aid for
		// later concurrency detection
		routeInfo[route].firstConnection = nextSegment;
		for (var i=start; i<end; i++) {
		    var edgePoints = new Array(2);
		    edgePoints[0] = [waypoints[i].lat, waypoints[i].lon];
		    edgePoints[1] = [waypoints[i+1].lat, waypoints[i+1].lon];
		    var segmentLength = distanceInMiles(waypoints[i].lat,
							waypoints[i].lon,
							waypoints[i+1].lat,
							waypoints[i+1].lon);
		    totalMiles += segmentLength;
		    var color = unclinchedColor;
		    var opacity = 0.3;
		    if (segments[nextSegment] == clinched[nextClinchedCheck]) {
			color = clinchedColor;
			nextClinchedCheck++;
			clinchedMiles += segmentLength;
			opacity = 0.85;
		    }
                    connections[nextSegment] = L.polyline(edgePoints, {
                        color: color,
                        weight: polylineWeight,
                        opacity: opacity
                    }).addTo(map);
		    let routesHere = new Array();
		    routesHere.push(route);

		    // expand out across hidden waypoints for user-meaningful
		    // endpoints and length
		    // also build list of waypoint coords for highlightConnection
		    let hcPointList = new Array();
		    let segStart = i;
		    while (segStart > start && !waypoints[segStart].visible) {
			segStart--;
		    }
		    let segEnd = i+1;
		    while (segEnd < end && !waypoints[segEnd].visible) {
			segEnd++;
		    }
		    let length = distanceInMiles(waypoints[segStart].lat,
						 waypoints[segStart].lon,
						 waypoints[segStart+1].lat,
						 waypoints[segStart+1].lon);
		    hcPointList.push(L.latLng(waypoints[segStart].lat,
					      waypoints[segStart].lon));
		    hcPointList.push(L.latLng(waypoints[segStart+1].lat,
					      waypoints[segStart+1].lon));
		    for (let point = segStart + 1; point < segEnd; point++) {
			length += distanceInMiles(waypoints[point].lat,
						  waypoints[point].lon,
						  waypoints[point+1].lat,
						  waypoints[point+1].lon);
			hcPointList.push(L.latLng(waypoints[point+1].lat,
						  waypoints[point+1].lon));
		    }

		    // Look for any previous polyline at the exact
		    // same location and make it transparent if found.
		    // We only need to find most recently added as its
		    // addition would have taken care of any even
		    // earlier match.  This is done efficiently by
		    // searching only among segments of the same length
		    // which are stored in the values of properties
		    // of the segmentLengths object with the key
		    // as the length of the segment

		    if (segmentLengths.hasOwnProperty(segmentLength)) {
			let sameLengths = segmentLengths[segmentLength];
			for (var sL = sameLengths.length-1; sL >= 0; sL--) {
			    let latLngs = connections[sameLengths[sL]].getLatLngs();
			    // check for match in either direction
			    if ((waypoints[i].lat == latLngs[0].lat &&
				 waypoints[i].lon == latLngs[0].lng &&
				 waypoints[i+1].lat == latLngs[1].lat &&
				 waypoints[i+1].lon == latLngs[1].lng)
				||
				(waypoints[i+1].lat == latLngs[0].lat &&
				 waypoints[i+1].lon == latLngs[0].lng &&
				 waypoints[i].lat == latLngs[1].lat &&
				 waypoints[i].lon == latLngs[1].lng)) {
				connections[sameLengths[sL]].setStyle({opacity: 0});
				// find the route at sameLengths[sL] and add it
				// to the routesHere (concurrencies)
				for (let rNum = 1; rNum < routeInfo.length -1 ; rNum++) {
				    if (routeInfo[rNum].firstConnection > sameLengths[sL]) {
					routesHere.push(rNum-1);
					break;
				    }
				}
				// used to have break; here, but now need to
				// final all concurrencies for popups
			    }
			}
			// add this segment to the existing list of segments
			// of this exact length
			sameLengths.push(nextSegment);
		    }
		    else {
			// this is the first time we've seen a segment of
			// this length, so this creates a new property
			// and initializes its value to a one-element
			// array with this segment number
			segmentLengths[segmentLength] = [ nextSegment ];
		    }

		    // now we have everything to add the listener on this
		    // polyline
		    connectionListener({
			connIndex: nextSegment,
			routes: routesHere,
			endpoints: waypoints[segStart].label + " <-> " + waypoints[segEnd].label,
			length: length,
			hcPointList: hcPointList
		    });
                    nextSegment++;
		}
	    }
	    // set up listener for changes to zoom level and adjust
	    // weight in response
	    map.on('zoomend', zoomChange);
	    zoomChange();
	}
	else {
	    // single route, should be the HB
	    for (var i=0; i<segments.length; i++) {
		var edgePoints = new Array(2);
		edgePoints[0] = [waypoints[i].lat, waypoints[i].lon];
		edgePoints[1] = [waypoints[i+1].lat, waypoints[i+1].lon];
		var segmentLength = distanceInMiles(waypoints[i].lat,
						    waypoints[i].lon,
						    waypoints[i+1].lat,
						    waypoints[i+1].lon);
		totalMiles += segmentLength;
		var color = "#cccccc";
		if (segments[i] == clinched[nextClinchedCheck]) {
		    color = "#ff8080";
		    nextClinchedCheck++;
		    clinchedMiles += segmentLength;
		}
                connections[i] = L.polyline(edgePoints, {
                    color: color,
                    weight: polylineWeight,
                    opacity: 0.75
                }).addTo(map);
		connectionListener({connIndex: i});
	    }
	}
        if (document.getElementById('controlboxinfo') != null) {
  	    document.getElementById('controlboxinfo').innerHTML = ""; //clinchedMiles.toFixed(2) + " of " + totalMiles.toFixed(2) + " miles (" + (clinchedMiles/totalMiles*100).toFixed(1) + "%) clinched by " + traveler + ".";
        }
    }
    else if (genEdges) {
	// this case is only WPT files loaded into HDX, which is an
	// unusual case generally better handled by loading the WPT file
	// into the HB (via the DB), so only minimal support is offered,
	// and no connectionListener is applied
          var polypoints=new Array();
         for(var way=0;way<waypoints.length;way++){ polypoints[i] = [waypoints[i].lat, waypoints[i].lon];}
        connections[0] = L.polyline(polypoints, {
            color: "#0000FF",
            weight: polylineWeight,
            opacity: 0.75
        }).addTo(map);
    }
    else {
	console.log("updateMap: unexpected case!");
    }
}

function lookupColors(color, tier, system) {

    // support for clinch colors from systems.csv
    let unclinchedColor = "rgb(200,200,200)"; //"#cccccc";
    let clinchedColor = "rgb(255,128,128)"; //"#ff8080";
    for (let c = 0; c<colorCodes.length; c++) {
	if (colorCodes[c].name == color) {
	    unclinchedColor = colorCodes[c].unclinched;
	    clinchedColor = colorCodes[c].clinched;
	}
    }
    // override with tier or system colors given in query string if they match
    //
    // once a name match is found, check if it's specifying CSS colors
    // for unclinched and clinched (if fields by those names exist in
    // that array entry), or specifying to use a predefined color from
    // systems.csv (if the TMcolor field exists in the array entry)
    let cIndex = 0;
    for (cIndex = 0; cIndex<customColorCodes.length; cIndex++) {
	if (customColorCodes[cIndex].name == ("tier"+tier) ||
	    customColorCodes[cIndex].name == system) {
	    break;
	}
    }
    // did we find one?
    if (cIndex < customColorCodes.length) {
	if (customColorCodes[cIndex].hasOwnProperty('TMcolor')) {
	    for (let c = 0; c<colorCodes.length; c++) {
		if (colorCodes[c].name == customColorCodes[cIndex].TMcolor) {
		    unclinchedColor = colorCodes[c].unclinched;
		    clinchedColor = colorCodes[c].clinched;
		    break;
		}
	    }
	}
	else {
	    unclinchedColor = customColorCodes[cIndex].unclinched;
	    clinchedColor = customColorCodes[cIndex].clinched;
	}
    }
    return [unclinchedColor, clinchedColor];
}

// find a color to use to draw an edge in a graph, where colors represent
// the number of concurrent routes on a segment or traveler frequency
function getGraphEdgeColor(edge) {

    let color;
    
    if (haveTravelers) {
	if (edge.travelerList.length == 0) {
	    // gray for untraveled segments
	    color = "#808080";
	}
	else if (edge.travelerList.length == 1) {
	    // single-traveler routes get special treatment in yellow
	    color = "#FFFF00";
	}
	else {
	    // blue-purple-red scale for others
	    //let rank = 250 * edge.travelerList.length/maxEdgeTravelers;
	    //let r = 5 + rank;
	    //let b = 255 - rank;
	    //
	    // instead:
	    // map 2 to green, through the blues, to red at maxEdgeTravelers
	    //let range = maxEdgeTravelers - 2;
	    //let pos = edge.travelerList.length - 2;
	    let range = Math.log10(maxEdgeTravelers);
	    let pos = Math.log10(edge.travelerList.length);
	    // first half between green and blue, second between blue and red
	    if (pos < range/4) {
		// 120-180 hue, red 0, green 255, blue 0 at 120 to 255 at 180
		color = "rgb(0,255," + (255*(pos/(range/4))) + ")";
	    }
	    else if (pos < range/2) {
		// 180-240 hue, red 0, green 255 at 180 to 0 at 240, blue 255
		color = "rgb(0," + (255-(255*(pos-range/4)/(range/4))) +
		    ",255)";
	    }
	    else if (pos < 3*range/4) {
		// 240-300, red 0 at 240 to 255 at 300, green 0, blue 255
		color = "rgb(" + 255*((pos-range/2)/(range/4)) + ",0,255)";
	    }
	    else {
		// 300-360, red 255, green 0, blue 255 at 300 to 0 at 360
		color = "rgb(255,0," +
		    (255-(255*(pos-3*range/4)/(range/4))) + ")";
	    }
	}
	//console.log("edge has " + edge.travelerList.length + " travelers out of " + maxEdgeTravelers + ", color is " + color);
    }
    else {
	// count the commas, which tell us how many concurrent routes are
	// represented, as they will be comma-separated, then use that to
	// choose a color to indicate the number of routes following the
	// edge
	let concurrent = edge.label.split(",").length;
	if (concurrent >= concurrencyColors.length) {
	    concurrent = concurrencyColors.length - 1;
	}
	color = concurrencyColors[concurrent];
    }
    return color;
}

// determine a color for the background shading of table entries
// for a route with the given distance traveled and total distance
// make sure this matches with tm_color_for_amount_traveled in
// tmphpfuncs.php
function colorForAmountTraveled(traveled, total) {

    let l = "80%";
    if (traveled == 0) l = "70%";
    if ((1.0*traveled).toFixed(2) == (1.0*total).toFixed(2)) l = "70%";
    return "hsl( " + (240*traveled/total) + ", 70%, " + l + ")";
}

// determine a color for the segment color for a route with the given
// distance traveled and total distance
function segmentColorForAmountTraveled(traveled, total) {

    // avoid division by 0 when there are no travelers in a region
    if (total == 0) return "#505050";

    // special dark gray for 0 travelers
    if (traveled == 0) return "#505050";
    
    // special purple for 1 traveler on a segment
    if (traveled == 1) return "hsl(300, 100%, 50%)";
    
    // otherwise, red through orange, yellow, green, to blue for increasing travelers
    return "hsl( " + (240.0*traveled/total) + ", 100%, 50%)";
}

// when the map is zoomed, we change the weight of polylines, setting
// the global variable polylineWeight, also used for map panning and
// resizing in the case of scrollable mapview
function zoomChange() {

    let oldPW = polylineWeight;
    let level = map.getZoom();
    if (level < 9) polylineWeight = 2;
    else if (level < 12) polylineWeight = 6;
    else if (level < 15) polylineWeight = 10;
    else polylineWeight = 16;
    // if this is from a reload of visible data, we're going to redraw anyway
    // so no need to update old connections (note that these are Mapview
    // specific functions, but this is OK since showAllInView will only
    // be true when displaying a Mapview page.
    if (showAllInView) {
	startDataLoading();
	mapviewUpdateVisibleDataDebounced();
    }
    // otherwise, update them only if the weight changed
    else if (polylineWeight != oldPW) {
	for (var i=0; i<connections.length; i++) {
	    connections[i].setStyle({weight: polylineWeight});
	}
	if (highlightConnection != null) {
	    highlightConnection.setStyle({weight: polylineWeight*2});
	}
    }
}

// debounce from https://github.com/mout/mout/blob/master/src/function/debounce.js
/**
 * Debounce callback execution
 */
function debounce(fn, threshold, isAsap){
    var timeout, result;
    function debounced(){
        var args = arguments, context = this;
        function delayed(){
            if (! isAsap) {
                result = fn.apply(context, args);
            }
            timeout = null;
        }
        if (timeout) {
            clearTimeout(timeout);
        } else if (isAsap) {
            result = fn.apply(context, args);
        }
        timeout = setTimeout(delayed, threshold);
        return result;
    }
    debounced.cancel = function(){
        clearTimeout(timeout);
    };
    return debounced;
}

// variable that would be set by any code that wishes to register
// an additional function to be called on a marker click
var labelClickCallback = null;

// set that variable
function registerMarkerClickListener(func) {

    labelClickCallback = func;
}

function addMarker(marker, i) {

    marker.addTo(map);
    
    marker.on('click', function() {
	intersectingConcurrentRoutes(i, true);
	if (labelClickCallback != null) {
	    labelClickCallback(i);
	}
    });
}

// note: there is also a labelClickHDX used when selecting start and
// end vertices for HDX algorithm visualizations
// this one is only called by the HB when someone clicks on
// a waypoint in the table (not on the map)
function labelClick(i, label, lat, lon, errors) {
    markers[i].bindPopup('<p style="line-height:160%;"><span style="font-size:24pt;color:black;">' + wpt.label + '</span><br><b>Waypoint ' + i + '<\/b><br><b><a target="_blank" href="http://www.openstreetmap.org/?lat='+wpt.lat+'&lon='+wpt.lon+'">Coords.:<\a><\/b> ' +
 wpt.lat + '&deg;, ' + wpt.lon + '&deg;<\/p><div id="intersections' + i + '"><\/div>');
    markers[i].openPopup();
    intersectingConcurrentRoutes(i, false);
    map.panTo([lat, lon]);
}


// variable that would be set by any code that wishes to register
// an additional function to be called on a connection (polyline) click
var connectionClickCallback = null;

// set that variable
function registerConnectionClickListener(func) {

    connectionClickCallback = func;
}

// handle clicks on connections (Leaflet Polylines)
function connectionClick(arg){

    let v1;
    let v2;
    let i = arg.connIndex;
    let gotPos = false;
    let deepZoom = map.getZoom() > 12;
    console.log("connectionClick: " + i);
    if (mapStatus == mapStates.HDX) {
	// TMG, GRA, NMP
	if (graphEdges.length > 0) {
	    v1 = waypoints[graphEdges[i].v1];
	    v2 = waypoints[graphEdges[i].v2];
	    gotPos = true;
	}
    }
    else if (mapStatus == mapStates.HB_ROUTE) {
	console.log("connectionClick: Code should no longer happen!");
	v1 = waypoints[i];
	v2 = waypoints[i+1];
	gotPos = true;
    }
    else if (mapStatus == mapStates.MAPVIEW) {
	// TBD if anything
	// for now, let gotPos remain false since v1 and v2 are not set
    }
    if (gotPos && !deepZoom) {
	let midlat = (parseFloat(v1.lat) + parseFloat(v2.lat))/2.0;
	let midlon = (parseFloat(v1.lon) + parseFloat(v2.lon))/2.0;
	map.panTo([midlat, midlon]);
    }

    connections[i].unbindPopup();
    connections[i].bindPopup(connectionInfo(arg));
    connections[i].openPopup();

    // overlay highlight for the clicked segment
    // use the connection's points
    let pointList = connections[i].getLatLngs();
    // but override if a larger list has been built and
    // stored to indicate adjacent segments are part
    if (arg.hasOwnProperty('hcPointList')) {
	pointList = arg.hcPointList;
    }
    highlightConnection = L.polyline(pointList, {
	color: "black",
	weight: polylineWeight*2,
	opacity: 0.4
    }).addTo(map);

    // if zoomed in deep, move popup to click point, otherwise
    // move popup to northernpost endpoint or shaping point
    // so popup does not obscure the connection's Polyline
    if (deepZoom) {
	connections[i].getPopup().setLatLng(arg.e.latlng);
    }
    else {
	let north = pointList[0];
	for (let i = 1; i < pointList.length; i++) {
	    if (pointList[i].lat > north.lat) {
		north = pointList[i];
	    }
	}
	connections[i].getPopup().setLatLng(north);
    }

    // registered additional callback
    if (connectionClickCallback != null) {
	connectionClickCallback(i);
    }
}

// called when any connection popup is closed, so we undo any connection
// highlighting
function connectionPopupClose() {

    highlightConnection.remove();
    highlightConnection = null;
}

function intersectingConcurrentRoutes(i, atCenter) {

    console.log("intersectingConcurrentRoutes: Code should no longer happen!");
    if (waypoints[i].hasOwnProperty('intersecting')) {
	intersections = "<p>Intersecting/Concurrent Routes:<br />";
	if (atCenter) {
	    lat = map.getCenter().lat.toFixed(6);
	    lon = map.getCenter().lng.toFixed(6);
	} else {
	    lat = waypoints[i].lat;
	    lon = waypoints[i].lon;
	}
	for (var j = 0; j < waypoints[i].intersecting.length; j++) {
	    r = waypoints[i].intersecting[j];
	    intersections+="<a href=\"/hb/showroute.php?r=" + r.root + "&lat=" + lat + "&lon=" + lon + "&zoom=" + map.getZoom() + "\">" + r.region + " " + r.route;
	    if (r.banner != "") {
		intersections+=" " + r.banner;
	    }
	    if (r.city != "") {
		intersections+=" (" + r.city + ")";
	    }
	    intersections += "</a><br />";
	}
	intersections += "</p>";
	document.getElementById("intersections"+i).innerHTML = intersections;
    }
}

// generate the popup text when connections[arg.connIndex]'s
// Polyline is clicked
function connectionInfo(arg){

    let i = arg.connIndex;
    let info = '';
    // do we already have an info property attached?
    if (connections[i].hasOwnProperty("TMpopupinfo")) {
	info += connections[i].TMpopupinfo;
    }
    // if a graph edge, get graph info
    else if (graphEdges.length > 0) {
	info += '<span style="font-size:24pt; color:black">' +
	    graphEdges[i].label + '</span><br /><b>Edge Number: '
	    + (i) + '<\/b><br><b>Endpoints:<\/b> ' +
	    waypoints[graphEdges[i].v1].label + ' <-> ' +
	    waypoints[graphEdges[i].v2].label +
	    '<br /><b>Distance: </b>' +
	    length_in_current_units(edgeLengthInMiles(graphEdges[i]));
    }
    // maybe we're in a multi-route view, like mapview
    // and info is provided in the parameter
    else if (mapStatus == mapStates.MAPVIEW) {
	let r = arg.routes[0];
	info += '<span style="font-size:18pt; color:black">' +
	    '<a target="_blank" href="/hb/showroute.php?r=' + routeInfo[r].root + '">' +
	    routeInfo[r].label + '</a></span><br />' +
	    arg.endpoints + "<br /><b>Length: </b>" +
	    length_in_current_units(arg.length);
	if (arg.routes.length > 1) {
	    info += "<br /><b>Concurrent with:</b> ";
	}
	for (let j = 1; j < arg.routes.length; j++) {
	    info += '<a target="_blank" href="/hb/showroute.php?r=' +
		routeInfo[arg.routes[j]].root + '">' +
		routeInfo[arg.routes[j]].label + "</a> ";
	}
	info += "<br />";
    }
    // else it is just a route, like in HB, get info from endpoint waypoints
    // but try to avoid hidden waypoints as they're uninteresting to users
    else {
	// build list of waypoint coords for highlightConnection
	arg.hcPointList = new Array();
	let start = i;
	while (start > 0 && !waypoints[start].visible) {
	    start--;
	}
	let end = i+1;
	while (end < waypoints.length -1 && !waypoints[end].visible) {
	    end++;
	}
	info += waypoints[start].label + ' <-> ' +
	    waypoints[end].label + '</br><b>Length: </b> ';
	let length = distanceInMiles(waypoints[start].lat,
				     waypoints[start].lon,
				     waypoints[start+1].lat,
				     waypoints[start+1].lon);
	arg.hcPointList.push(L.latLng(waypoints[start].lat,
				      waypoints[start].lon));
	arg.hcPointList.push(L.latLng(waypoints[start+1].lat,
				      waypoints[start+1].lon));
	for (let point = start + 1; point < end; point++) {
	    length += distanceInMiles(waypoints[point].lat,
				      waypoints[point].lon,
				      waypoints[point+1].lat,
				      waypoints[point+1].lon);
	    arg.hcPointList.push(L.latLng(waypoints[point+1].lat,
					  waypoints[point+1].lon));

	}

	info += length_in_current_units(length);
    }
    
    if (haveTravelers) {
	let travelers = '';
	for (let j = 0; j < graphEdges[i].travelerList.length; j++) {
	    travelers += travelerNames[graphEdges[i].travelerList[j]] + ' ';
	}
	
	info += '<br /><span title="' + travelers + '"><b>' + graphEdges[i].travelerList.length + ' Traveler';
	if (graphEdges[i].travelerList.length != 1) {
	    info += 's';
	}
	info += '</b>';
	if (graphEdges[i].travelerList.length > 0) {
	    if (graphEdges[i].travelerList.length <= 5) {
		info += ': ' + travelers;
	    }
	    else {
		info += ' (mouse over for list)';
	    }
	}
	info += '</span>';
    }
    // if we just computed new info, save it
    if (!connections[i].hasOwnProperty("TMpopupinfo")) {
	connections[i].TMpopupinfo = info;
    }
    return '<p style="line-height:160%;">' + info + '</p>';
}


// compute the length of an edge in miles
function edgeLengthInMiles(e) {

    if (!e.hasOwnProperty("length")) {
	let len = 0.0;
	if (e.via == null) {
	    // no intermediate points: easy case
	    len = distanceInMiles(waypoints[e.v1].lat, waypoints[e.v1].lon,
				  waypoints[e.v2].lat, waypoints[e.v2].lon);
	}
	else {
	    // account for intermediate points in "via" array
	    len = distanceInMiles(waypoints[e.v1].lat, waypoints[e.v1].lon,
				  parseFloat(e.via[0]), parseFloat(e.via[1]));
	    for (var pos = 0; pos < e.via.length - 2; pos += 2) {
		len += distanceInMiles(parseFloat(e.via[pos]),
				       parseFloat(e.via[pos+1]),
				       parseFloat(e.via[pos+2]),
				       parseFloat(e.via[pos+3]));
	    }
	    len += distanceInMiles(parseFloat(e.via[e.via.length-2]),
				   parseFloat(e.via[e.via.length-1]),
				   waypoints[e.v2].lat, waypoints[e.v2].lon);
	}
	e.length = len;
    }
    return e.length;
}

// compute distance (with TM fudge factor) along a list of LatLng objects
function pathLengthInMiles(points) {

    let length = distanceInMiles(points[0].lat, points[0].lng,
				 points[1].lat, points[1].lng);
    for (let i = 1; i < points.length - 1; i++) {
	length += distanceInMiles(points[i].lat, points[i].lng,
				  points[i+1].lat, points[i+1].lng);
    }
    return length;
}

// compute distance in miles between two lat/lon points
function distanceInMiles(lat1, lon1, lat2, lon2) {
    if(lat1 == lat2 && lon1 == lon2)
	return 0.;
    
    var rad = 3963.;
    var deg2rad = Math.PI/180.;
    var ang = Math.cos(lat1 * deg2rad) * Math.cos(lat2 * deg2rad) * Math.cos((lon1 - lon2)*deg2rad) + Math.sin(lat1 * deg2rad) * Math.sin(lat2 * deg2rad);
    return Math.acos(ang) * 1.02112 * rad;
}

// compute distance in feet between two lat/lon points
function distanceInFeet(lat1, lon1, lat2, lon2) {
    if(lat1 == lat2 && lon1 == lon2)
	return 0.;
    
    var rad = 3963.;
    var deg2rad = Math.PI/180.;
    var ang = Math.cos(lat1 * deg2rad) * Math.cos(lat2 * deg2rad) * Math.cos((lon1 - lon2)*deg2rad) + Math.sin(lat1 * deg2rad) * Math.sin(lat2 * deg2rad);
    return Math.acos(ang) * 1.02112 * rad * 5280;
}

// GraphEdge constructor, vertex numbers can come in as strings or
// numbers, will store as numbers
function GraphEdge(v1, v2, label, trav, via) {

    // v1 and v2 are the indices into the vertices array of
    // the edge's endpoints
    if (typeof v1 === 'string') {
	this.v1 = parseInt(v1);
	this.v2 = parseInt(v2);
    }
    else {
	this.v1 = v1;
	this.v2 = v2;
    }
    // edge label
    this.label = label;

    // traveler hex string
    this.travelerList = null;
    if (trav != null) {
	// parse the hex code into a list of travelers of this segment
	this.travelerList = new Array();
	// the bits of the first hex character represent the travels
	// of the first 4 travelers (0-3), the next character represents
	// the travels of the next 4 travelers (4-7), etc.
	let nextTrav = 0;
	for (let pos = 0; pos < trav.length; pos++) {
	    switch (trav[pos]) {
	    case '1':
		this.travelerList.push(nextTrav);
		break;
	    case '2':
		this.travelerList.push(nextTrav+1);
		break;
	    case '3':
		this.travelerList.push(nextTrav);
		this.travelerList.push(nextTrav+1);
		break;
	    case '4':
		this.travelerList.push(nextTrav+2);
		break;
	    case '5':
		this.travelerList.push(nextTrav);
		this.travelerList.push(nextTrav+2);
		break;
	    case '6':
		this.travelerList.push(nextTrav+1);
		this.travelerList.push(nextTrav+2);
		break;
	    case '7':
		this.travelerList.push(nextTrav);
		this.travelerList.push(nextTrav+1);
		this.travelerList.push(nextTrav+2);
		break;
	    case '8':
		this.travelerList.push(nextTrav+3);
		break;
	    case '9':
		this.travelerList.push(nextTrav);
		this.travelerList.push(nextTrav+3);
		break;
	    case 'A':
		this.travelerList.push(nextTrav+1);
		this.travelerList.push(nextTrav+3);
		break;
	    case 'B':
		this.travelerList.push(nextTrav);
		this.travelerList.push(nextTrav+1);
		this.travelerList.push(nextTrav+3);
		break;
	    case 'C':
		this.travelerList.push(nextTrav+2);
		this.travelerList.push(nextTrav+3);
		break;
	    case 'D':
		this.travelerList.push(nextTrav);
		this.travelerList.push(nextTrav+2);
		this.travelerList.push(nextTrav+3);
		break;
	    case 'E':
		this.travelerList.push(nextTrav+1);
		this.travelerList.push(nextTrav+2);
		this.travelerList.push(nextTrav+3);
		break;
	    case 'F':
		this.travelerList.push(nextTrav);
		this.travelerList.push(nextTrav+1);
		this.travelerList.push(nextTrav+2);
		this.travelerList.push(nextTrav+3);
		break;
	    }
	    nextTrav += 4;
	}
    }

    // array of shaping points (or null)
    this.via = via;

    return this;
}

// callback for when the hideMarkers checkbox is clicked
function showMarkersClicked() {

    var showThem = document.getElementById('showMarkers').checked;
    if (showThem) {
	for (var i = 0; i < waypoints.length; i++) {
	    if (waypoints[i].visible) {
		addMarker(markers[i], i);
	    }
	}
    }
    else {
	for (var i = 0; i < waypoints.length; i++) {
	    markers[i].remove();
	}
    }
}

// listen for clicks on connections/Polylines
function connectionListener(arg){
    connections[arg.connIndex].on('click',
				  function(e){
				      // pass along MouseEvent info
				      arg.e = e;
				      connectionClick(arg);
				  });
    connections[arg.connIndex].on('popupclose',
				  function(e){
				      connectionPopupClose();
				  });
}


function redirect(url) {
    var win = window.open(url);
    win.focus();
}

// JS debug window by Mike Maddox from
// http://javascript-today.blogspot.com/2008/07/how-about-quick-debug-output-window.html
var DBG = {
    write : function(txt){
	if (!window.dbgwnd){
	    window.dbgwnd = window.open("","debug","status=0,toolbar=0,location=0,menubar=0,directories=0,resizable=0,scrollbars=1,width=600,height=250");
	    window.dbgwnd.document.write('<html><head></head><body style="background-color:black"><div id="main" style="color:green;font-size:12px;font-family:Courier New;"></div></body></html>');
	}
	var x = window.dbgwnd.document.getElementById("main");
	this.line=(this.line==null)?1:this.line+=1;
	txt=this.line+': '+txt;
	if (x.innerHTML == ""){
	    x.innerHTML = txt;
	}
	else {
	    x.innerHTML = txt + "<br/>" + x.innerHTML;
	}
    }
}
